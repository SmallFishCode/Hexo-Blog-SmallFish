---
title: 操作系统前置基础知识
date: 2022/11/23 21:15:00
tags: 浏览器
categories: 浏览器
cover: /img/bg7.jpg
---


# 操作系统前置基础知识

> 计算机的三层架构：机器硬件在最底层，操作系统在中间，应用在最上面。

![](https://camo.githubusercontent.com/cefdb8f3af9d02523d297a536f1354cc10c3f011de367f715990f89b86f3530c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f3136343439352f313631343530383232313435332d37323133346135302d643463372d343230372d616237312d3933643161663635623233612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333134266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d6370752e706e67266f726967696e4865696768743d333134266f726967696e57696474683d3539332673697a653d3737313935267374617475733d646f6e65267374796c653d6e6f6e652677696474683d353933)

在学习浏览器架构之前，我们先来了解一下前置的一些操作系统的基础知识，包括 CPU、GPU、进程、线程 等。

### 1. CPU（Central Processing Unit）

> CPU（中央处理单元）就是芯片，是作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。

##### N1: CPU 可以被认为是你的计算机的大脑

其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。

一个 CPU 核心，在这里被描绘成一个办公室工作人员，可以在许多不同的任务进来时一项一项地处理它们。它可以处理从计算到渲染的一切事情，同时知道如何回复访问者的行为。

在过去，大多数 CPU 是一个单一的芯片。在现代硬件中，通常会有一个以上的核心，给你的手机和笔记本电脑带来更多的计算能力。

##### N2: CPU 的工作原理

冯诺依曼体系结构是现代计算机的基础。在该体系结构下，程序和数据统一存储，指令和数据需要从同一存储空间存取，经由同一总线传输，无法重叠执行。根据冯诺依曼体系，CPU的工作分为以下 5 个阶段：取指令阶段、指令译码阶段、执行指令阶段、访存取数和结果写回。

- 取指令（IF，instruction fetch），即将一条指令从主存储器中取到指令寄存器的过程。程序计数器中的数值，用来指示当前指令在主存中的位置。当 一条指令被取出后，程序计数器（PC）中的数值将根据指令字长度自动递增。

- 指令译码阶段（ID，instruction decode），取出指令后，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类 别以及各种获取操作数的方法。现代CISC处理器会将拆分已提高并行率和效率。

- 执行指令阶段（EX，execute），具体实现指令的功能。CPU的不同部分被连接起来，以执行所需的操作。

- 访存取数阶段（MEM，memory），根据指令需要访问主存、读取操作数，CPU得到操作数在主存中的地址，并从主存中读取该操作数用于运算。部分指令不需要访问主存，则可以跳过该阶段。 

- 结果写回阶段（WB，write back），作为最后一个阶段，结果写回阶段把执行指令阶段的运行结果数据“写回”到某种存储形式。结果数据一般会被写到CPU的内部寄存器中，以便被后续的指令快速地存取；许多指令还会改变程序状态字寄存器中标志位的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作。

在指令执行完毕、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就从程序计数器中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令。 [1]  许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。

##### N3: CPU 的调度算法（待补充）

---

### 2. GPU （Graphics Processing Unit）

##### N1: GPU 简介

图形处理器又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上做图像和图形相关运算工作的微处理器。

一个光栅显示系统离不开图形处理器，图形处理器是图形系统结构的重要元件，是连接计算机和显示终端的纽带。

应该说有显示系统就有图形处理器 (俗称显卡)，但是早期的显卡只包含简单的存储器和帧缓冲区，它们实际上只起了一个图形的存储和传递作用，一切操作都必须由 CPU 来控制。

这对于文本和一些简单的图形来说是足够的，但是当要处理复杂场景特别是一些真实感的三维场景，单靠这种系统是无法完成任务的。所以后来发展的显卡都有图形处理的功能。它不单单存储图形，而且能完成大部分图形功能，这样就大大减轻了 CPU 的负担，提高了显示能力和显示速度。

随着电子技术的发展，显卡技术含量越来越高，功能越来越强，许多专业的图形卡已经具有很强的3D处理能力，而且这些3D图形卡也渐渐地走向个人计算机。一些专业显卡具有的晶体管数甚至比同时代的 CPU 的晶体管数还多。比如2000年加拿大ATI公司推出的 RADEON 显卡芯片含有3千万颗晶体管，达到每秒15亿个像素填写率。

##### N2: CPU 和 GPU 的区别？

CPU 和 GPU 之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU 需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得 CPU 的内部结构异常复杂。而 GPU 面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。

---

### 3. 什么是进程？

> 进程是系统进行 **资源分配** 的最小单位

- 进程可以看作应用的执行程序。线程是存在于进程里面，并且可以执行进程的任一部分程序。

- 当我们启动一个应用的时候，就会创建一个进程。程序可能会创建多个线程去帮助其工作，当然这是可选的。操作系统会给进程分配内存块，应用程序的所有状态都可以保存在该私有空间。当关闭程序的时候，进程会消失并且操作系统也会释放内存。

- 一个进程可以向操作系统申请另外一个进程来执行不同的任务，操作系统将为新进程分配另外一部分内存。如果两个进程想要通信，他们需要使用 Inter Process Communication （进程间通信）。很多应用都是以这种方式 工作的，如果一个进程无响应，可以直接重启该进程，而不需要停止执行应用程序其他部分的进程。

##### N1: 为什么要有进程？

对于计算机的使用者来说，会通过运行的程序来完成种种任务。而“程序，是为了实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。” 用大白话来说，程序就是告诉计算机怎样一步步地完成我们交给它的任务。

既然程序要运行，要完成某种任务，那么怎样完成，需要什么资源进行协助，这是必然要面对的问题。进而在此之上抽象出了“进程“的概念。“进程是资源分配的最小单位”这个常用的概念能贴切地说明一些情况。试想一下，如果各个要运行的程序，对所涉及的资源没有被管理、隔离、保护，势必会出乱子。联想到个人的资产，如果可以被他人随意地获取、使用，也就会带来各式各样的问题。而资源，就是程序的“资产”。

进程的出现，不仅仅解决了资源分配的为题，还解决了另一个重要问题，并发———使 CPU 资源能够充分地被利用。

程序的运行离不开 CPU 的参与，进程作为程序的抽象自然也需要。因而引出一个概念，“每个进程都有自己的虚拟 CPU ”。是的，进程都认为 CPU 就应该是自己的，都想尽可能地运行足够多的时间。但是 CPU 只有一个或者若干个，进程可以有更多个，因此不管是单 CPU 还是多 CPU，面对的都是“如何将特有资源分配给更多需求者使用”的问题。此后文章就取单核 CPU的情况来看，足以说明问题，也能简化问题。

CPU 由谁来使用，就成了必须面对的问题，由此引出了“进程间如何进行调度”的问题，所以进程也是进行调度的独立单位。CPU 被视为一种资源，按照某种规则，让不同的进程可以在特定的时机占用。有时候，不同的进程间还可以拥有其他的共同资源，就像人可以拥有共同资产一样。既然涉及到了共同资源，那么各方希望就会对这份资源的变动保持敏感，希望能得知这份共同资源的真实变动信息。因此引出了另一个问题，“进程间的通信”问题，即资源或数据的变动，在各种情况下保持正确性。

针对这两个问题，下文会针对性地做梳理，这里不妨先了解进程是什么样子。

##### N2: 进程小 demo
“小明，18岁，185cm，在球场上打球”，与人一样，进程有自己的样子与正在做的事情，操作系统维护着一份表格来描述这份信息，这张表格即为进程表。每个进程占用一个进程表，表里有各种字段来表示不同的信息。大致分为三类信息，进程管理、存储管理、文件管理。其中：

- 进程管理包括：寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、调度参数、进程ID、父进程、进程组、信息、进程开始时间、使用CPU的时间、子进程的CPU时间、下次定时器时间等。

- 存储管理包括：正文段指针、数据段指针、堆栈段指针。

- 文件管理包括：根目录、工作目录、文件描述符、用户ID、组ID。

与此同时，每个进程还拥有自己的内存地址空间以可以对各类数据进行操作，一般而言，进程之间是 **不可以访问对方的内存地址空间的。** 这就像人的房子，其他人不能随便的访问，往自己的房子里增添物件也只是个人的事。
有了这些信息，进程就有了轮廓，操作系统才可能正确地调度运行这些进程，完成并发。

并发，即使指在一段时间内，有若干事情在进行，但在任一时刻，仅有一件事情在进行。区别于并行，并行则为某一时刻，可以有若干事情在进行。如图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af24780cb0f44bb9a3896ed085bb027d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

在多 CPU 的情况下，能够实现一定范围的内并行，但更多时候，以并发来看进程的执行更加合适。

并发所解决的问题无疑是必要的。日常工作中，挂着音乐听着歌，开着微信聊着天，后台还运行着邮箱等着邮件的到来，这些运行的程序是各式各样进程在进行并发。试想一下，如果没有并发，使用某个程序的时候其他的程序就不能被使用，会发生什么。聊天的时候不能听歌，听歌的时候不能工作，等邮箱的时候就只能干巴巴地等着。效率低下，又不愉快。

实际上，很多进程更多的时候是在等待一些条件如  [I/O](https://zh.m.wikipedia.org/zh-cn/I/O) 等才能继续进行下一步，真正需要执行的地方需要时间很短，如果在等待的时间还要占用 CPU，则白白浪费了 CPU 资源。就像一个邮件程序，可以几十秒甚至几分钟去检查一下有没有新的邮件即可，相比于等待邮件到来的时间，“检查”这一操作需要的时间非常短，也因此只要在特定的规律时间内让它占用一下 CPU 即可。

当有很多类似的进程时，并发就能让更多的进程在一段时间内做更多的事情。

并发释放了CPU的劳动力，让更多进程能参与使用，提高了CPU的利用率。CPU利用率 = 1 - p^n， 其中p为进程等待条件的时间/使用CPU的时间，n为进程数，此公式可仅做了解。

##### N3: 进程的状态 (待补充)

##### N3: 进程的创建、终止、层次结构 (待补充)

##### N4: 进程死锁

> 什么是死锁：不允许两个或多个进程同时占用，若不能采取其他措施，这种循环等待状况会无线持续下去，就发生进程死锁。

产生死锁的的必要条件

- 互斥条件：某个资源在一段时间内只能由一个进程占用，不能同时被两个或两个以上的进程占有。

- 不可抢占条件：进程所获得的资源在未使用完毕之前，资源申请者不能强行从资源占有者手中夺取，只能由该资源的占有者自行释放。

- 占有申请条件：进程至少已经占有一个资源，但又申请新的资源，但申请的资源已被另外的进程占有，此时该进程阻塞；但他在等待新资源时，还在占用已占有的资源。

- 循环等待条件：存在一个进程等待序列{p1,p2,...pn},p1等待P2占有资源，P2等待P3占用资源，.....,而Pn等待p1占用资源，这样形成一个进程等待循环。

如何预防死锁？(待补充)

---

### 4. 什么是线程？

> 线程是操作系统能够进行 **调度的** 最小单位。它被包含在进程之中，是进程中的 实际运作单位

##### N1: 为什么要有线程?

有了进程之后，程序已能如期运行，那为什么何还要有线程呢。试想一下，当需要使用共同的资源，并通过若干个可同时进行的事件共同达成某个任务时，如果使用进程间进行合作，会很复杂与困难，因为进程的设计，希望资源是自己的，别的进程不能轻易访问。

线程的出现，使这样的问题迎刃而解。就和写代码一样，完成了解耦，也就是将程序的资源管理与执行隔离开来，线程就是负责执行的。所以，“线程是调度和分配的最小单位”。如同大家处于同一个小组，小组如同进程，大家拥有共同的资源，当一起执行某个任务时，A负责冲锋陷阵，B负责后勤... 这即是将执行分开的由来。

线程除了访问共同资源简单，分离了执行之外，另一个有点是更轻量级。通过某些手段，进程间也能在使用共同资源的情况下合作某个任务，但是进程的创建、切换更消耗时间。在许多系统中，可达到10 ～ 100倍。无论进程、线程，他们的运行都需要CPU的参与，当进程间需要相互切换时，将发生系统调用。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/359b86ba3a92440c94d9a9750f09d01d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

系统调用为发生了从 用户态 -> 内核态 -> 用户态 的过程，我们的程序运行在用户态，但有些时候需要借助系统提供的服务才能进行某项事务，就要通过系统调用从用户态进入内核态，继而进行这项事务。完成之后，再从内核态回到用户态，继续运行我们的程序。从用户态到内核态，需要暂停当前用户态的执行，然后存储上下文，对于用户态发来的系统调用，内核态是不信任的，因此需要做各项的检查。内核态执行完之后，再回复之前存储的上下文，回到用户态继续执行。

对于进程间的切换来说，最重要的耗时部分，就在于切换上下文。进程模型抽象出了进程的虚拟地址空间，进程间的虚拟地址空间的切换，会发生页表查找，而页表查找，是一个很慢的过程。

线程间的切换则轻量得多（指同一进程内的）。其中的区别就像，你在自己的房子里，在客厅看电视，然后去厨房倒了一杯水， 与从你家，走到你的朋友家讨杯水喝的区别。

---

### 5. 进程和线程引入的问题？

前文有提到过，进程需要 CPU 的参与以及访问公共资源，对于进程来说的共享资源比如某些公用的文件，希望使用的 I/0 设备如打印机等。这就涉及到了两个重要的问题需要处理：

- CPU 的分配，也就是如何进行调度，即某一时间，由谁来使用 CPU。
- 通信问题，当使用共享资源时，需要知道它的真实状态，如果按照资源的过时信息进行使用，将使程序进入异常状态

线程与进程面对的问题，是相似的。

##### N1: 如何解决进程间的通信问题？(待补充)

##### N2: 如何解决资源分配问题？(待补充)


