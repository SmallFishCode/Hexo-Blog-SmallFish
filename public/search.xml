<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>预编译</title>
      <link href="/2022/01/27/js/%E9%A2%84%E7%BC%96%E8%AF%91/"/>
      <url>/2022/01/27/js/%E9%A2%84%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列（四）-预编译"><a href="#大厂面试题系列（四）-预编译" class="headerlink" title="大厂面试题系列（四）-预编译"></a>大厂面试题系列（四）-预编译</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本期我们要讲的同样是面试干货-预编译的原理，有关于预编译的知识点在小黄书包括很多经典书籍上并没有给出详细的解释和介绍，所以在本文会给大家详细的讲解和介绍。</p><h2 id="发生在函数体的预编译"><a href="#发生在函数体的预编译" class="headerlink" title="发生在函数体的预编译"></a>发生在函数体的预编译</h2><h3 id="关于预编译"><a href="#关于预编译" class="headerlink" title="关于预编译"></a>关于预编译</h3><p>我们再上一期的变量提升中了解到，变量提升是发生在<code>编译阶段</code>，而赋值操作是发生在<code>执行阶段</code>，而预编译，则是<code>发生在执行的前一刻</code>。</p><h3 id="函数执行前一刻的预编译"><a href="#函数执行前一刻的预编译" class="headerlink" title="函数执行前一刻的预编译"></a>函数执行前一刻的预编译</h3><p>这里我们引用一下上一期当中的代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例1.1</span><br><span class="line">function fn (a) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);     // function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    var a = 123</span><br><span class="line"></span><br><span class="line">    console.log(a);     // 123</span><br><span class="line"></span><br><span class="line">    function a() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    console.log(a);     // 123</span><br><span class="line"></span><br><span class="line">    var b = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    console.log(b);     //  function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function d() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(1)</span><br></pre></td></tr></table></figure><p>还是这段熟悉的代码，唯一的不同之处就在于这次我们在调用函数fn的时候，传入了一个参数1。在上一期当中我们是直接使用变量提升的规则来理清楚了这段函数的运行结果，那么今天我们就用预编译的规则来理一理：</p><p>大家可以先跟我走一遍，存在不明白的地方很正常，先跟着我一起走完一遍，到最后小编会给出总结，到时候大家就能明白了。</p><p>来吧，首先如果有小伙伴对执行上下文还不太了解的话可以去我们系列第二篇（作用域进阶）了解一下执行上下文之后再来学习本期内容，会更好理解一些。</p><p>首先，我们都知道函数执行会产生一个函数的执行上下文，我们在这里简称为AO(Activation Object)，那么<code>在AO当中储存的正是函数当中各种变量的值</code>，在例1.1当中，函数fn执行会产生一个AO对象。</p><p>在创建AO对象之后，我们<code>先来找有无变量声明和形参</code>，很显然在例1.1当中，第一个变量声明是var a，那么在AO中就有一个属性名为a的一个变量，那么它的值为多少呢？此时正处于预编译阶段，并不是执行阶段，所以不会执行赋值操作所以 <strong>此时a的值为 undefined</strong> 。</p><p>然后我们接着找变量声明，第二个变量声明为var b，注意，此处<strong>是一个函数表达式，并不是函数声明</strong> ， 那么同样，b 的值也为 undefined，好了，找到这里我们发现已经没有变量声明了。</p><p>那我们来找形参，有一个形参为a，传入的值为 1，我们<code>将形参与实参的值统一</code>，那么此时a 的值就为1.</p><p>走完上面那一步之后我们接着往下看，这个时候我们就可以<code>在函数体里找函数声明</code>，从上往下，第一个就是函数a的声明，那么好了，此时AO对象中已经存在一个变量a了，还会继续添加一个新的a为函数吗？很显然在JavaScript中是不允许声明两个相同的变量的，所以此时，a的值1将会被覆盖，被[Function: a]覆盖掉了，然后我们继续往下走第二个是函数d的声明，同样此时d的值为[Function: d]。</p><p>好，走到这里我们算是把函数执行前一刻的预编译理清楚了，然后就是函数内部从上往下执行代码，我们先来看看此时AO对象里面存放了哪些值？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例1.2</span><br><span class="line">AO: &#123;</span><br><span class="line">    a: undefined -&gt; 1 -&gt; function a () &#123;&#125;</span><br><span class="line">    b: undefined</span><br><span class="line">    d: function d () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在函数预编译的时候并不会产生上面这么一段代码，而是会产生一个结构，想了解的同学，在第二篇作用域进阶当中有一些图片大家可以看看。</p><p>那么好，预编译执行完了，我们开始执行代码，从上往下，第一个就是console.log(a)，那么此时的a的值为[Function: a]，<strong>所以这行代码运行的结果就为[Function: a]。</strong><br>继续往下看，有一个a = 123的赋值操作，将a的值又重新赋值为了123，所以<strong>下面两个console.log(a)的值都为 123.</strong> ，接着往下走，有一个赋值操作将[Function: b]赋值给了变量b，所以<strong>最后一个console.log(b)的值就为[Function: b]。</strong> 到这里，整个过程就算结束了，得出的最后答案和我们通过变量提升直接得出的答案是一样的，还没有理清楚的小伙伴可以多看两边上面的解析，后面我们会一起总结。</p><h2 id="发生在全局下的预编译"><a href="#发生在全局下的预编译" class="headerlink" title="发生在全局下的预编译"></a>发生在全局下的预编译</h2><h3 id="预编译不仅仅发生在函数体内"><a href="#预编译不仅仅发生在函数体内" class="headerlink" title="预编译不仅仅发生在函数体内"></a>预编译不仅仅发生在函数体内</h3><p>预编译同样会发生在全局下，那么在全局下的预编译又是怎样进行的呢？如果你已经理解了函数执行前一刻的预编译，那么接下来你就能很清晰的理解全局下的预编译，也是那么几个步骤，我们先一起走一遍，最后再做个总结。</p><h3 id="全局下的预编译"><a href="#全局下的预编译" class="headerlink" title="全局下的预编译"></a>全局下的预编译</h3><p>同样的，我们先来看一段简单的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例2.1</span><br><span class="line">var global = 100</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(global);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>好，这段代码是不是异常简单，没错，确实简单，但是有个小细节需要大家注意，一会儿大家就知道了，那么你先想想，这段代码的运行结果会是多少呢？相信你的答案应该是100，没错，这段代码的运行结果的确为100，<strong>如果面试官问你，为什么是100呢？</strong> 那么你可能就会说因为函数内部可以访问到外部的变量所以为100，<strong>那么面试官又问了：为什么函数内部可以访问到外部的变量呢？</strong> 这个时候你就可以拿出我们第二篇中所讲到的作用域链的知识来解答了，好，那么真的是这么个流程嘛？我们一起来看看。</p><p>首先，我们执行的前一刻，<code>全局会产生一个GO对象</code>，就是全局的执行上下文，和函数一样，我们先找变量声明，有一个var global 的声明，所以此时global的值为undefined。</p><p><code>找完了变量声明我们再找函数声明</code>，有个函数fn的声明，那么此时GO中又多了一个变量fn，值为[Function: fn],到这里全局的预编译就执行完了，然后就是函数fn也会进行预编译，按照上一节所讲的步骤可知函数fn的AO对象里面没有变量（本身自带的一些this，arguments除外），所以现在的AO和GO我们来看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例2.2</span><br><span class="line">GO: &#123;</span><br><span class="line">    global: undefined ,</span><br><span class="line">    fn: function () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AO:&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行阶段，因为赋<strong>值操作是在函数fn的调用之前，所以会先进行赋值操作，再进行函数的调用</strong>，所以最终代码运行结果为：100</p><h2 id="预编译总结"><a href="#预编译总结" class="headerlink" title="预编译总结"></a>预编译总结</h2><p>好了讲到这里想必大家多多少少对预编译的过程有个大概的了解了，那么我再来给大家总结一下：<br>首先，预编译发生在函数执行前的前一刻  ( 四部曲 ) ( 函数体 )</p><ol><li><p>Js 引擎会创建 AO 对象(Activation Object)</p></li><li><p>找形参和变量声明，将变量声明和形参作为Ao的属性名，值为undefined</p></li><li><p>将实参和形参值统一</p></li><li><p>在函数体里找函数声明，将函数名作为Ao对象的属性名，值赋予函数体</p></li></ol><p>发生在全局下的预编译：</p><ol><li><p>创建 GO 对象</p></li><li><p>找形参和变量声明，将变量声明和形参作为GO的属性名，值为undefined</p></li><li><p>在全局里找函数声明，将函数名作为GO对象的属性名，值赋予函数体</p></li></ol><p>如果看到第三节还是一知半解的同学，我建议可以把小结多看几遍，然后根据总结的部分再回到前面去看看能不能自己写出来AO 和GO。</p><p>本期文章就写到这里啦，我们下期见~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 全栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升</title>
      <link href="/2022/01/27/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/2022/01/27/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列（三）-变量提升"><a href="#大厂面试题系列（三）-变量提升" class="headerlink" title="大厂面试题系列（三）-变量提升"></a>大厂面试题系列（三）-变量提升</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文会讲到的主要内容也是前端面试绕不开的一大话题<strong>变量提升</strong>，看到这篇文章的朋友们想必已经对作用域和作用域链有了一个基本的了解了，如果还不了解的话建议看看小编的面试系列一和二，对理解本文会有一点帮助，那么话不多说，我们步入主题。</p><h2 id="代码是怎么运行的"><a href="#代码是怎么运行的" class="headerlink" title="代码是怎么运行的"></a>代码是怎么运行的</h2><p>首先我们来看看代码是怎么运行的，大家都知道<strong>JavaScript中执行顺序是从上到小的</strong>,那么在运行的过程中，是否真的是简单的从上往下执行呢？我们来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例1.1</span><br><span class="line">var myName = &quot;小明&quot;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(myName);</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><h3 id="变量提升发生的场景"><a href="#变量提升发生的场景" class="headerlink" title="变量提升发生的场景"></a>变量提升发生的场景</h3><p>这段代码很简单，打印结果为 <strong>小明 hello</strong> ，好，那我们再看接下来的一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例1.2</span><br><span class="line">console.log(myName);</span><br><span class="line">var myName = &quot;小明&quot;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><p>那么这段代码的运行结果又是什么呢？按照代码从上往下执行的原则，结果会报错，为什么呢？因为打印myName的时候还没有声明myName，所以会报错，那么结果真的会是这样吗？</p><p>不，这段代码的运行结果是 <strong>undefined hello</strong> ， 哎，很多同学到这可能就有很多疑问了，问什么会是undefined呢？ 好，先不要着急，我们接着看一段代码：</p><h3 id="函数提升发生的场景"><a href="#函数提升发生的场景" class="headerlink" title="函数提升发生的场景"></a>函数提升发生的场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例1.3</span><br><span class="line">showName()</span><br><span class="line">console.log(myName);</span><br><span class="line">var myName = &quot;小明&quot;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多小伙伴看到这里就会说了，哎在例1.2中打印的是undefined，那么这里shouName()，同样也是在声明之前调用，那么结果一定是两个undefined吧，实则不然，这段代码的打印结果是 <strong>hello undefined</strong> ，看到这里想必有些小伙伴已经脑袋晕了吧，不要着急，我们先做个小总结：</p><h3 id="代码运行小结"><a href="#代码运行小结" class="headerlink" title="代码运行小结"></a>代码运行小结</h3><ul><li><p>在执行过程中，若使用未声明的变量，Js 执行会报错</p></li><li><p>在一个变量定义之前使用它，不会报错，但是该变量的值为undefined ，而不是定义的值</p></li><li><p>在一个函数定义之前使用它，是不会报错的，且函数能正确执行</p></li></ul><h2 id="变量提升现象"><a href="#变量提升现象" class="headerlink" title="变量提升现象"></a>变量提升现象</h2><p>首先，什么是变量提升呢？变量提升就是： <strong>javascript 代码在执行过程中，javascript 引擎会把变量声明部分和函数声明部分提升到代码的最前面的”行为”</strong> </p><p>在例1.2中，在编译阶段会发生变量提升现象，所以引擎执行时候的代码可以理解成以下样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例2.1</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var myName;</span><br><span class="line">console.log(myName);</span><br><span class="line">myName = &quot;小明&quot;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><p>这样一看，是不是就能合理的解释为什么运行结果是 undefined 和 hello 了。这就是JavaScript当中存在的变量提升，从例2.1当中我们看到函数整体和变量myName的声明提升到了当前作用域的顶端，相信细心的小伙伴此时就会发现，<strong>函数是整体提升，而变量只有声明部分被提升了，赋值部分仍然留在原地</strong>。另外一点，也是一个小细节：<strong>函数声明提升的优先级是高于变量声明提升的。</strong></p><h3 id="变量提升优先级"><a href="#变量提升优先级" class="headerlink" title="变量提升优先级"></a>变量提升优先级</h3><p>来看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例2.2</span><br><span class="line">function fn () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);     // </span><br><span class="line"></span><br><span class="line">    var a = 123</span><br><span class="line"></span><br><span class="line">    console.log(a);     // </span><br><span class="line"></span><br><span class="line">    function a() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    console.log(a);     // </span><br><span class="line"></span><br><span class="line">    var b = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    console.log(b);     // </span><br><span class="line"></span><br><span class="line">    function d() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>我把代码运行结果写在下面，因为可以让大家先自己想一想运行结果是个什么样子，然后再来到下面对比一下看看自己有没有写对。那么以上代码按顺序打印的结果是：[Function: a] ， 123 ， 123 ， [Function: b] 。我觉得只要理解了上文讲的变量提升，想必大家都能理解这段代码的运行结果，那么仍然不太理解的小伙伴也不要着急，我们一起来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例2.3</span><br><span class="line">function fn () &#123;</span><br><span class="line">    function a () &#123;&#125;</span><br><span class="line">    function d () &#123;&#125;</span><br><span class="line">    var b ;</span><br><span class="line"></span><br><span class="line">    console.log(a);  // function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    a = 123</span><br><span class="line"></span><br><span class="line">    console.log(a);    //123</span><br><span class="line"></span><br><span class="line">    console.log(a);     //123</span><br><span class="line"></span><br><span class="line">    b = function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    console.log(b);     //function&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>好了，这么一看，大家是不是就能完全理解变量提升了。如果还不能理解的话，我建议可以多看看上面这两段代码，直到能完全理解它。</p><h3 id="用let和const声明的变量是否存在变量提升？"><a href="#用let和const声明的变量是否存在变量提升？" class="headerlink" title="用let和const声明的变量是否存在变量提升？"></a>用let和const声明的变量是否存在变量提升？</h3><p>初步理解了变量提升之后，那么问题又来了，用let和const声明的变量是否存在变量提升呢？来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例2.4</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        var a = 2</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>以上代码运行结果为2,2。相信大家应该能理解，那么我们再来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例2.5</span><br><span class="line">function foo() &#123;</span><br><span class="line">    let a = 1</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        let a = 2</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>那么这段代码的运行结构还会是2,2,吗？不，在这段代码中，由于变量a都是由let声明的，而用let声明的变量是支持块级作用域的，所以在if{}内部声明的let a = 2和外面声明的let a = 1 是在两个不同的作用域中，所以if当中声明的变量a 无法提升到外部，所以这么来看的话let声明的变量是不存在变量提升的，为什么呢？这就涉及到另一个知识点了。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>暂时性死区（temporal dead zone，简称 TDZ）是指：ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<strong>其次在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</strong>。</p><p>正是因为这种机制，所以用let声明的变量是不会发生变量提升现象的，更准确的来说，也可以这么理解，let声明的变量是存在变量提升的，但是由于存在暂时性死区，导致变量提升的效果不存在了，所以这么来看的话，我们可以直接理解为用let声明的变量不存在变量提升。</p><p>暂时性死区方便了我们日常使用，防止变量泄露到外部，导致运行出错。</p><h2 id="变量提升小结"><a href="#变量提升小结" class="headerlink" title="变量提升小结"></a>变量提升小结</h2><ol><li><p>变量提升是javascript 代码在执行过程中，javascript 引擎会把变量声明部分和函数声明部分提升到代码的最前面的”行为”</p></li><li><p>变量提升只是变量声明部分提升</p></li><li><p>函数提升是函数整体提升</p></li><li><p>变量提升发生在编译环节，而赋值操作发生在执行阶段</p></li><li><p>函数声明提升会优先于变量声明提升（导致变量声明被覆盖）（若是还有函数名相同的函数需要提升，则会覆盖之前提升的函数声明）</p></li><li><p>用let声明的变量不存在变量提升现象</p></li></ol><p>好的，记住以上内容，如果还有不理解的地方的话可以收藏本文，先往下看，以后可以回过头来看看，就会理解的更深刻一些。</p><p>本系列会由浅入深，全面的讲解到前端面试所需要具备的知识体系，所以看完的小伙伴觉得作者写的还不错的话可以点点不要钱的赞，支持一下，同时也方便以后查找，我们下期见~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 全栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS作用域进阶</title>
      <link href="/2022/01/25/js/scoped2/"/>
      <url>/2022/01/25/js/scoped2/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列（二）-作用域进阶"><a href="#大厂面试题系列（二）-作用域进阶" class="headerlink" title="大厂面试题系列（二）-作用域进阶"></a>大厂面试题系列（二）-作用域进阶</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要会对系列（一）所讲解的作用域进行更深一层的讲解，包括<strong>作用域的查找规则</strong>，<strong>执行上下文</strong>和<strong>作用域链</strong>三个方面的内容。</p><h2 id="作用域的查找规则"><a href="#作用域的查找规则" class="headerlink" title="作用域的查找规则"></a>作用域的查找规则</h2><p>在上文中，我们提到作用域的相关概念：<strong>作用域是一套设计良好的规则来储存变量，并且之后可以方便的找到这些变量</strong>。那么作用域是如何查找和访问变量的呢？在本节中会给出答案。</p><h3 id="演员表和对话"><a href="#演员表和对话" class="headerlink" title="演员表和对话"></a>演员表和对话</h3><p>在学习作用域的过程中，我们可以将整个过程模拟成几个人物之间的对话。那么首先我们先来认识一下这场对话中的的‘演员们’，先来一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例1.1</span><br><span class="line">var a = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先介绍一下演员表：</p><ul><li><p><strong>引擎</strong>：从头到尾负责整个JavaScript 程序的编译及执行过程</p></li><li><p><strong>编译器</strong>：引擎的好朋友之一。负责语法部分分析及代码生成等脏活累活</p></li><li><p><strong>作用域</strong>：引擎的另一位好朋友，负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，以确定当前执行代码对这些标识符的访问权限。</p></li></ul><p>例1.1是一个简单的声明赋值语句，那么当这句代码执行的时候，演员们是如何工作的呢？</p><p>在执行变量的赋值操作时，会执行两个工作：</p><ol><li><p>首先编译器会在当前作用域中声明一个变量（如果之前没有声明过）</p></li><li><p>在运行时，引擎会在作用域中查找该变量，如果能找到就会对它进行赋值</p></li></ol><p>也就是说在例1.1当中，首先var a 声明一个变量a，然后引擎在作用域中查找到变量a，进行a = 2 的赋值操作。</p><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>在例1.1当中，引擎会为变量a进行LHS查询，另外一个查找类型叫做RHS。</p><p>顾名思义换句话说：当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时，进行RHS查询。</p><ul><li><p><strong>LHS：试图找到变量的容器本身，从而对其进行修改（赋值）</strong></p></li><li><p><strong>RHS：简单的查找某个变量的值，不用对其进行操作。</strong></p></li></ul><p>那么这么讲，你是否明白了什么时候用LHS，什么时候用RHS呢？</p><h3 id="引擎和作用域的对话"><a href="#引擎和作用域的对话" class="headerlink" title="引擎和作用域的对话"></a>引擎和作用域的对话</h3><p>上面讲到了引擎会为变量进行LHS或RHS，在这个过程中，作用域发挥一个怎么样的作用呢？先来一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例1.2</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">    console.log(a);  // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure><p>让我们来看一段引擎和作用域之间的对话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">引擎:我说作用域，我需要为foo 进行RHS 引用。你见过它吗?</span><br><span class="line">作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。</span><br><span class="line">引擎:哥们太够意思了!好吧，我来执行一下 foo。</span><br><span class="line">引擎:作用域，还有个事儿。我需要为a进行LHS 引用，这个你见过吗?</span><br><span class="line">作用域:这个也见过，编译器最近把它声明为foo的一个形式参数了，拿去吧。</span><br><span class="line">引擎:大恩不言谢，你总是这么棒。现在我要把2赋值给a。</span><br><span class="line">引擎:哥们，不好意思又来打扰你。我要为console 进行RHS 引用，你见过它吗?</span><br><span class="line">作用域:咱俩谁跟谁啊，再说我就是干这个的。这个我也有，console是个内置对象。给你。</span><br><span class="line">引擎:么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。</span><br><span class="line">引擎:哥们，能帮我再找一下对a的RHS引用吗?虽然我记得它，但想再确认一次。</span><br><span class="line">作用域:放心吧，这个变量没有变动过，拿走，不谢。</span><br><span class="line">引擎:真棒。我来把a的值，也就是2，传递进log(..)。</span><br></pre></td></tr></table></figure><p>就是上面这段经典的对话，生动的描绘出了引擎和作用域是如何配合工作的看到这里相信你已经对作用域的查找规则有个清晰的认识了。</p><p>所以在这里留下一道题给大家练练手：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例1.3</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">    var b = a;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = foo(2)</span><br></pre></td></tr></table></figure><p>请问在例1.3中有几处LHS查询，几处RHS查询呢？欢迎大家在评论区留下答案。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d1d45865ba24c0ca597342e8a9d9bf8~tplv-k3u1fbpfcp-watermark.image" alt="作用域.png"></p><p>还是这张熟悉的图，在图中我们可以看到最内层的bar函数作用域，中间有foo的函数作用域，最外层存在全局作用域，那么这样一个嵌套的过程，就被称为<strong>作用域嵌套</strong>。</p><p>所以什么叫做作用域链呢：当引擎从当前的作用域开始查找变量，如果找不到，就会向上一级继续查找，直到找到变量或者已经到达全局作用域仍然找不到就会停止，那么在这个查找过程中，会<strong>产生一个成链式连接的集合：储存着执行期上下文对象的集合</strong>，这种结构就可以称为作用域链。那么什么是执行上下文呢？我们接着往下看</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>那么什么又是执行上下文呢？</p><p>在作用域中，储存着<strong>运行期的上下文</strong>：当函数执行时会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是<strong>独一无二</strong>的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文会被销毁</p><p>先来一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例3.1</span><br><span class="line">function a () &#123;</span><br><span class="line">    function b() &#123;</span><br><span class="line">        var b = 234</span><br><span class="line">        console.log(a)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    var a = 123</span><br><span class="line">    b()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var glob = 100</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>那么在上面这段代码执行时会产生什么呢？我们先看一张图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3679d21db6554112913669dc54b67258~tplv-k3u1fbpfcp-watermark.image" alt="2.jpg"></p><ul><li><p>首先是函数a声明的时候会产生一个 <strong>[[scope]]</strong>,其中就包含着一个一个的执行上下文，这些集合就被称为<strong>scope chain</strong>（作用域链），因为函数a定义在全局，所以一定会有一个 <strong>Global Object</strong>（全局执行上下文），在全局上下文中，包含一些内置的键值对，包括this，指向window，以及我们在全局定义的变量glob，值为100.</p></li><li><p>当执行到a() 时，执行函数a，会产生a的执行上下文：</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b8e786cd3494a809cbe4b1678f9c514~tplv-k3u1fbpfcp-watermark.image" alt="2.png"></p><ul><li><p>当a执行的时候（橙色线条），GO（全局执行上下文）在作用域链中会被挤到1的位置上，函数a自己的执行上下文（AO）会挤到最顶端，也就是0的位置，这也就是为什么查找变量是由内而外，<strong>从作用域链的最顶端开始查找</strong>。</p></li><li><p>最后在函数a当中执行函数b的时候，也是相同的规则：</p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3696de0922b44e1d8b5db84b9c9a8c57~tplv-k3u1fbpfcp-watermark.image" alt="3.png"></p><ul><li>红色的线条代表的就是函数b被执行的时候，0的位置存放着b的执行上下文，1的位置放着a函数a的执行上下文，2的位置上放着全局的执行上下文。</li></ul><p>如果有文章中写的不够透彻或者有不明白的地方欢迎在评论区留言~<br>本期就讲到这里了，下期见~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 全栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS作用域(一)</title>
      <link href="/2022/01/24/js/scoped/"/>
      <url>/2022/01/24/js/scoped/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列-初识作用域"><a href="#大厂面试题系列-初识作用域" class="headerlink" title="大厂面试题系列-初识作用域"></a>大厂面试题系列-初识作用域</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>   前端面试必考题-作用域，算是入门级必须掌握的一块知识，JavaScript中有一个特性叫作用域（Scope）         </p><p>   <strong>scope: 每个javascript函数都是一个对象，对象中有些属性是我们可以访问的，但是有些不可以，scope 这个属性就是其中之一，它只能被javascript引擎存取</strong></p><p>   话不多说，先上一段简短的代码体验一下作用域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例1.1</span><br><span class="line">function foo () &#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p>看完上面这段代码，请问打印出的2个a的值是多少呢？都是1吗？相信有基础的同学一眼就能看出答案：第一个a的值为1，第二个a应该会报错（ a is not defined）。这个时候不知道有没有同学会觉得，a不是等于1吗？为什么会报错呢？这就是作用域了，下面我们就一起来揭秘一下~</p><h2 id="初识作用域"><a href="#初识作用域" class="headerlink" title="初识作用域"></a>初识作用域</h2><p>注：有基础的同学可以直接跳过这一节</p><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>小黄书上对作用域的解释是：<strong>作用域是一套设计良好的规则来储存变量，并且之后可以方便的找到这些变量</strong>。刚接触js的小白们看不懂也不要紧张，接着往后看，看完还不懂评论区留言我上门一对一辅导哈哈哈~<br>话不多说，接着上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例1.2</span><br><span class="line">function foo (a) &#123;</span><br><span class="line">    var b = a * 2</span><br><span class="line"></span><br><span class="line">    function bar (c) &#123;</span><br><span class="line">        console.log( a,b,c );</span><br><span class="line">    &#125;</span><br><span class="line">    bar( b * 3 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，存在着三个作用域：</p><ol><li>整个全局的作用域，在此作用域中只存在 foo 一个标识符。</li><li>函数foo所创建的作用域，在此作用域中存在 a，bar，b 三个标识符。</li><li>函数bar所创建的作用域，在此作用域中只存在 c 一个标识符。<br>下面上个经典的图来理解例1.2当中的作用域：</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a83965146064ba48d6249522b7be219~tplv-k3u1fbpfcp-watermark.image" alt="作用域.png"></p><p>不同颜色的气泡代表着不同的作用域，这样看作用域是不是更加显而易见。包括作用域中所存在的各个标识符。<strong>作用域气泡由其对应的作用域代码块写在哪里决定，它们是逐级包含的。后面会讲到不同类型的作用域，现在只要假设每一个函数都会创建一个作用域气泡就好了</strong>。</p><p>在此处先介绍一下作用域的两种主要的工作模式：第一种是最为普遍的，被大多数编程语言所采用的<strong>词法作用域</strong>，后面会对词法作用域进行深入的讲解。另外一种叫作<strong>动态作用域</strong>，后面也会略做讲解。</p><h3 id="作用域的作用是什么？"><a href="#作用域的作用是什么？" class="headerlink" title="作用域的作用是什么？"></a>作用域的作用是什么？</h3><p><strong>作用域是在运行的时候，对某些变量，函数和对象的可访问性</strong>。什么意思呢？我们还是来看一段代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例1.3</span><br><span class="line">function foo () &#123;</span><br><span class="line">    var a = 1</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(a);     // a is not defined</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么这里打印a的值会是not defined呢？ 正是因为变量a是在函数foo中定义的，所以在全局环境下打印变量a自然会报错。</p><p>所以对于作用域的作用是什么我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><h2 id="作用域全家桶"><a href="#作用域全家桶" class="headerlink" title="作用域全家桶"></a>作用域全家桶</h2><p>在例1.2 和1.3 中我们都提到了全局作用域和函数作用域，那么在这一节中我们将会对‘作用域全家桶’有个深入的了解。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>什么是全局作用域？简单通俗的来说就是：<strong>定义在全局下的变量或函数都处在全局作用域当中。</strong></p><p>那么什么时候会产生全局作用域呢？话不多说，接着上代码：</p><p>（1）定义在全局的变量和函数，就会产生全局作用域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例2.1</span><br><span class="line">var a = &#x27;我是全局变量&#x27;      //  定义在全局的变量a</span><br><span class="line">function foo() &#123;     //  定义在全局的函数 </span><br><span class="line"></span><br><span class="line">    var b = &#x27;我在函数里面&#x27;   //    定义在函数foo中的变量b</span><br><span class="line">    function bar() &#123;    //  定义在函数foo中的函数</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量a和函数foo就处在全局作用域下，而变量b和函数bar在函数foo所产生的的函数作用域当中。</p><p>（2）直接赋值的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例2.2</span><br><span class="line">function foo() &#123;</span><br><span class="line">    a = 3</span><br><span class="line">    var b = 2</span><br><span class="line">&#125;</span><br><span class="line">foo()   // 执行foo才能执行里面的代码</span><br><span class="line">console.log(a);     // 3    </span><br><span class="line">console.log(b);     // b is not defined</span><br></pre></td></tr></table></figure><p>为什么这里的变量a会有值呢？因为变量a未声明而是直接赋值，所以会自动放入全局作用域中，而变量b就是正常情况下，定义在函数foo作用域中的变量在全局下无法访问。</p><p><strong>全局作用域的弊端</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例2.3</span><br><span class="line">var a = 2</span><br><span class="line"></span><br><span class="line">var a = 4</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p>如上所示，一旦代码量过于复杂，可能就会存在变量名相同的情况，导致命名冲突。</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>什么是函数作用域呢？简单来说：<strong>函数作用域就是在声明函数的时候，会产生一个作用域，这个作用域就被称为函数作用域</strong>。先上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例2.4</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2</span><br><span class="line">    bar()</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        var b = 1</span><br><span class="line">        console.log(b);     // 1</span><br><span class="line">        console.log(a);     // 2</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a);         // 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);             // a is not defined</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>在这段代码中，第一个打印b为1，是因为变量b是在函数bar的作用域中定义，所以可以正常打印出b的值。第二个打印a为什么值为2，这是因为在函数作用域中，<strong>内部的作用域可以访问到外部作用域的变量</strong>，而通过第四个打印a的值为not defined 可以看出来，<strong>从外部是无法访问到函数内部变量的</strong>。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES6 中引入的块级作用域，增加了对变量的可控性，大大的提高了变量使用的灵活性。</p><p>那么块级作用域在什么时候产生呢？-块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。<strong>一个块级作用域可以理解为一对花括号{}之间的区域</strong>。接着上代码：</p><p>（1）函数中的块级作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例2.5</span><br><span class="line">function foo() &#123;</span><br><span class="line">    let a = 1</span><br><span class="line">    console.log(a);     //  1</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(a);         //  a is not defined</span><br></pre></td></tr></table></figure><p>用let声明的变量a只在函数foo中有定义，而在此块级作用域外则没有定义。</p><p>（2）for循环中的块级作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例2.6</span><br><span class="line">for(let i = 0;i &lt; 3;i++) &#123;</span><br><span class="line">    console.log(i);     // 0,1,2</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);         // i is not defined</span><br></pre></td></tr></table></figure><p>变量i只在for循环中有定义，因为用let声明变量i产生了块级作用域，而在for循环外面则无法访问到变量i。</p><p>相信很多小伙伴看到例2.6的时候会有这么个疑惑：let声明的变量i到底是在括号内的作用域中还是在for循环内部的{}中呢？让我们来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例2.7</span><br><span class="line"></span><br><span class="line">for(let i = 0;i &lt; 3;i++) &#123;</span><br><span class="line">    let i = &#x27;a&#x27;</span><br><span class="line">    console.log(i);     // a,a,a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，循环体打印出了三个a，<strong>这说明在for循环当中，在括号内用let声明的变量会产生一个父作用域，而在循环体内会产生一个子作用域，那么为什么例2.6可以打印出1,2,3呢？这是因为内部作用域可以访问到外部作用域，在这里就是说，子作用域可以访问到父作用域的变量i</strong>，看到这里相信你一定对块级作用域有个认知了吧。</p><p><strong>注意：不可重复声明变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例2.8</span><br><span class="line">var a = 2</span><br><span class="line">let a = 1    //  Identifier &#x27;a&#x27; has already been declared</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在一个作用域中重复声明变量则会报错。</p><h2 id="作用域收关"><a href="#作用域收关" class="headerlink" title="作用域收关"></a>作用域收关</h2><p>看完了上面两节的内容相信大家已经对作用域有个初步的认识了吧，在第三节中，会聊到一些拓展以及作用域之后相关的内容，在后续也会更新发布本系列。</p><h3 id="作用域相关知识概要"><a href="#作用域相关知识概要" class="headerlink" title="作用域相关知识概要"></a>作用域相关知识概要</h3><p>在本文中只谈到了作用域的概念和一些不同的作用域，其实在作用域中还存放着一个叫做<strong>执行上下文</strong>的东西，以及<strong>作用域的查找规则</strong>和<strong>变量提升</strong>等内容，要学习这些内容必须熟练掌握作用域的知识所以在后续会发布相关文章来详细讲解面试系列。</p><h3 id="作用域产生的作用域链"><a href="#作用域产生的作用域链" class="headerlink" title="作用域产生的作用域链"></a>作用域产生的作用域链</h3><p>在此先简单的提到一下由许多作用域产生的作用域链，本系列中将作用域和其他相关内容分开，可以将每个内容的部分更加详细的描述到。</p><p><strong>作用域链：scope 中存储的执行期上下文对象的集合，这个集合成链式连接，我们把这种链式连接叫做作用域链</strong></p><p>觉得作者写的还行的可以动动小手点个赞支持一下哦，也可以关注作者，后续会写一整套面试系列内容~ 本文中存在错误也可以在评论区讨论哦！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 全栈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
